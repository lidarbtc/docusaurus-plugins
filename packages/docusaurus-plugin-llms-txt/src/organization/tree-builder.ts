/**
 * Copyright (c) SignalWire, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { getEffectiveConfigForRoute, getLlmsTxtConfig } from '../config';
import { findQualityIssues } from '../config/section-validator';
import { TREE_ROOT_NAME, INDEX_IDENTIFIER } from '../constants';
import { handleSectionError } from '../errors/section-errors';
import { ensureLeadingSlash, sortByPosition } from '../utils';

import type {
  DocInfo,
  PluginOptions,
  TreeNode,
  SectionDefinition,
  Logger,
} from '../types';

/**
 * Build hierarchical tree from docs using section-based organization
 */
export function buildDocumentTree(
  docs: readonly DocInfo[],
  globalConfig: PluginOptions,
  logger?: Logger
): TreeNode {
  // Get configuration groups
  const llmsTxtConfig = getLlmsTxtConfig(globalConfig);

  // 1. Create section definitions map for quick lookup
  const sectionsMap = buildSectionsMap(llmsTxtConfig.sections);

  // 2. Group documents by section
  // For manual sections: group by section ID
  // For auto-generated sections: group by path segment at autoSectionDepth
  const sectionGroups = new Map<string, DocInfo[]>();
  const autoSectionDepth = llmsTxtConfig.autoSectionDepth ?? 1;

  for (const doc of docs) {
    const route = doc.routePath.replace(/\.md$/, '');
    const routePath = ensureLeadingSlash(route);

    // Handle root index document - exclude from section grouping
    const segments = routePath.split('/').filter(Boolean);
    if (
      routePath === '/' ||
      (segments.length === 1 && segments[0] === INDEX_IDENTIFIER)
    ) {
      // Root index will be handled separately in buildLlmsTxtContent
      continue;
    }

    const effectiveConfig = getEffectiveConfigForRoute(routePath, globalConfig);
    const baseSectionId = effectiveConfig.section;
    const isManualSection = sectionsMap.has(baseSectionId);

    let finalSectionId: string;

    if (isManualSection) {
      // Manual sections: use the section ID as-is
      finalSectionId = baseSectionId;
    } else {
      // Auto-generated sections: determine section based on autoSectionDepth
      // If route is shallower, fall back to the actual depth
      const effectiveDepth = Math.min(autoSectionDepth, segments.length);
      const segmentIndex = effectiveDepth - 1;
      finalSectionId = segments[segmentIndex]!;
    }

    if (!sectionGroups.has(finalSectionId)) {
      sectionGroups.set(finalSectionId, []);
    }
    sectionGroups.get(finalSectionId)!.push(doc);
  }

  // 3. Create processed sections
  const processedSections = new Map<string, ProcessedSection>();

  for (const [sectionId, sectionDocs] of sectionGroups) {
    const isManualSection = sectionsMap.has(sectionId);
    const sectionDef =
      sectionsMap.get(sectionId) ||
      createAutoSection(sectionId, llmsTxtConfig.autoSectionPosition);
    const processedSection = createProcessedSection(
      sectionDef,
      sectionDocs,
      !isManualSection, // isAutoGenerated
      autoSectionDepth
    );
    processedSections.set(sectionId, processedSection);
  }

  // 4. Handle quality issues (empty sections, etc.)
  if (logger) {
    const qualityIssues = findQualityIssues(
      llmsTxtConfig.sections,
      processedSections,
      globalConfig.onSectionError || 'warn'
    );

    qualityIssues.forEach((issue) => {
      handleSectionError(issue, globalConfig.onSectionError || 'warn', logger);
    });
  }

  // 5. Filter out empty sections based on error handling setting
  const validSections = filterValidSections(
    processedSections,
    globalConfig.onSectionError || 'warn'
  );

  // 6. Build hierarchical tree structure
  const rootNode = buildHierarchicalTree(
    validSections,
    sectionsMap,
    globalConfig
  );

  // 7. Handle root index document
  const rootIndexDoc = docs.find((doc) => {
    const route = doc.routePath.replace(/\.md$/, '');
    const routePath = ensureLeadingSlash(route);
    const segments = routePath.split('/').filter(Boolean);
    return (
      routePath === '/' ||
      (segments.length === 1 && segments[0] === INDEX_IDENTIFIER)
    );
  });

  if (rootIndexDoc) {
    (rootNode as TreeNode & { indexDoc?: DocInfo }).indexDoc = rootIndexDoc;
  }

  return rootNode;
}

/**
 * Interface for processed section data
 */
interface ProcessedSection {
  id: string;
  name: string;
  description?: string;
  position?: number;
  docs: DocInfo[];
  parentId?: string;
  isAutoGenerated: boolean;
  autoSectionDepth: number;
}

/**
 * Build section definitions map with parent relationships
 */
function buildSectionsMap(
  sections: readonly SectionDefinition[]
): Map<string, SectionDefinition & { parentId?: string }> {
  const map = new Map<string, SectionDefinition & { parentId?: string }>();

  function addToMap(
    sectionList: readonly SectionDefinition[],
    parentId?: string
  ): void {
    for (const section of sectionList) {
      map.set(section.id, { ...section, parentId });

      if (section.subsections) {
        addToMap(section.subsections, section.id);
      }
    }
  }

  addToMap(sections);
  return map;
}

/**
 * Create auto-generated section definition
 */
function createAutoSection(
  sectionId: string,
  position?: number
): SectionDefinition {
  // Auto-create section with ID as name (title-cased)
  const name = sectionId
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');

  return {
    id: sectionId,
    name,
    ...(position !== undefined && { position }),
  };
}

/**
 * Create processed section from definition and docs
 */
function createProcessedSection(
  sectionDef: SectionDefinition & { parentId?: string },
  docs: DocInfo[],
  isAutoGenerated: boolean,
  autoSectionDepth: number
): ProcessedSection {
  return {
    id: sectionDef.id,
    name: sectionDef.name,
    description: sectionDef.description,
    position: sectionDef.position,
    docs: sortDocsByPath(docs),
    parentId: sectionDef.parentId,
    isAutoGenerated,
    autoSectionDepth,
  };
}

/**
 * Filter out empty sections based on error handling setting
 */
function filterValidSections(
  processedSections: Map<string, ProcessedSection>,
  onSectionError: 'ignore' | 'log' | 'warn' | 'throw'
): Map<string, ProcessedSection> {
  if (onSectionError === 'ignore') {
    return processedSections; // Include all sections, even empty ones
  }

  const validSections = new Map<string, ProcessedSection>();

  for (const [sectionId, section] of processedSections) {
    if (section.docs.length > 0) {
      validSections.set(sectionId, section);
    }
    // Empty sections are excluded unless ignoring errors
  }

  return validSections;
}

/**
 * Build hierarchical tree from processed sections
 */
function buildHierarchicalTree(
  processedSections: Map<string, ProcessedSection>,
  sectionsMap: Map<string, SectionDefinition & { parentId?: string }>,
  globalConfig: PluginOptions
): TreeNode {
  // Get structure configuration
  const llmsTxtConfig = getLlmsTxtConfig(globalConfig);

  // Create root node
  const root: TreeNode = {
    id: 'root',
    name: llmsTxtConfig.siteTitle || TREE_ROOT_NAME,
    description: llmsTxtConfig.siteDescription || '',
    relPath: '',
    docs: [],
    subCategories: [],
  };

  // Group sections by parent
  const topLevelSections: ProcessedSection[] = [];
  const subsectionsByParent = new Map<string, ProcessedSection[]>();

  for (const section of processedSections.values()) {
    if (section.parentId) {
      if (!subsectionsByParent.has(section.parentId)) {
        subsectionsByParent.set(section.parentId, []);
      }
      subsectionsByParent.get(section.parentId)!.push(section);
    } else {
      topLevelSections.push(section);
    }
  }

  // Build tree nodes
  function createTreeNode(
    section: ProcessedSection,
    parentPath: string = ''
  ): TreeNode {
    const manualSubsections = subsectionsByParent.get(section.id) || [];

    // Build relPath to indicate hierarchy depth
    // For top-level sections: just the section ID
    // For subsections: parent/section-id
    const relPath = parentPath ? `${parentPath}/${section.id}` : section.id;

    // Auto-generated sections are already at the correct level
    // (created from path segments at autoSectionDepth)
    // Manual sections may have subsections defined via parentId
    const subCategories = sortByPosition(
      manualSubsections.map((sub) => createTreeNode(sub, relPath))
    );

    return {
      id: section.id,
      name: section.name,
      description: section.description,
      position: section.position,
      relPath,
      docs: section.docs,
      subCategories,
    };
  }

  // Add top-level sections to root
  const mutableRoot = root as TreeNode & { subCategories: TreeNode[] };
  mutableRoot.subCategories = sortByPosition(
    topLevelSections.map((section) => createTreeNode(section))
  );

  return root;
}

/**
 * Sort documents by path hierarchy for better organization
 * Groups by path prefix, then by depth within prefix, then lexicographic
 */
function sortDocsByPath(docs: DocInfo[]): DocInfo[] {
  return docs.sort((a, b) => {
    // Get normalized paths without .md extension
    const pathA = a.routePath.replace(/\.md$/, '').split('/').filter(Boolean);
    const pathB = b.routePath.replace(/\.md$/, '').split('/').filter(Boolean);

    // Compare path segments from left to right
    const minLength = Math.min(pathA.length, pathB.length);

    for (let i = 0; i < minLength; i += 1) {
      const segmentA = pathA[i];
      const segmentB = pathB[i];
      if (segmentA && segmentB) {
        const comparison = segmentA.localeCompare(segmentB);
        if (comparison !== 0) {
          return comparison;
        }
      }
    }

    // If all common segments match, shorter path comes first
    return pathA.length - pathB.length;
  });
}
